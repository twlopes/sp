FEATURE LIST

- Make sure that it is the latest version of the aritcle being returned in all cases.  Highest version id.







- Lock up parts of the doc.


- Need to setup MailChimp.
- Do word based diffs (for display to users who don't want to see fine changes)?  http://code.google.com/p/google-diff-match-patch/wiki/LineOrWordDiffs
- Look into changing the standard bootstrap container.  Need more space and seperatino for the aritlce.  See quora for example.
- Create functionality to select versions.
- Relate articles to props with a new field for prop id in terms of changes made for new versions.
-Make a time line for the article. So and so changed constitution then. Prop proposed then. Like github.
-Make micro constitutions changeable by director. Or give them the option.
- Look into Gunicorn.
- Start working on two users in different browsers so that I can be sure that the permissions and following are working.
- User gets assigned permission or no.  When assigned permission, follow automatically switched on.
- If vote expired, it doesn't go through.
- Prop summary.
- Permissions for voting work - buttons need to not appear if you don't have permission.
- user can only vote once on prop.
- user cannot make more than one prop per 24 hours.
- user cannot make empty prop.
- Fix register/login page.
- Learn javascript:  http://learn.appendto.com/
- Do the end of the Python course of Zed Shaw.
- Do more CSS tutorial.
- Figure out how the South database migrations work.  Save having to redo data for testing.

LAUNCH

- Get onto Heroku.
- need to figure out how to keep settings credentials safe in django when putting it up to Github.
- Create great content.
- Create burner accounts.


MAKING SURE I HAVE THE LATEST VERSION

>>> x = Articles.objects.filter(cons_id=1).aggregate(Max('version_id'))
>>> x['version_id__max']
4 
(this is the versino number - but the database seems to grab the latest entry anyway.  Actually, that's the way to do it methinks.  Just do a search on the microcons id, order by "create" and cut off to 1.)


ELLO

I am building a collaborative authoring system with Django at the moment.

People make changes to documents by editing text in an HTML text area. I just pre-poulate the text area with the current version of the document and the user makes changes and hits "submit". The trick is that user changes to the documents need to get approval, so the changes are not implemented immediately. It's likely, of course, that two people will try and make changes to the same words or sentences at the same time.

I'd like to solve the problem with a "first come first served" rationale. If User_1 makes a change to a sentence, I'd like to grey that sentence out in User_2's textarea to the extent that it's changed by User1. User2 would then not be able to make changes to those phrases or words in the textarea.

Would love feedback on the following queries:

For the sake of completeness - can anyone think of a better approach than textareas locked up on a piece-meal basis to solve this collaboration problem? Would love to hear examples of sites with similar issues and what they do to solve it.

I'm presuming that a text area with javascript attributes is the way to go here. Anyone aware of plugins that do this kind of thing? Any hints on JS code to accomplish this? (I know very little about JS, having relied on libraries in the past)

I am going to need to get information about outstanding changes from the python server side to the JS client side. I think this is a job for a messaging system (like RabbitMQ). Is there a better way to do this? Are there server/client side protocols that I'm not aware of?

Look forward to collective wisdom magic!

___________

You are doing a really interesting project! The first thing that comes to mind is HTML5 Web Sockets for realtime messaging. I would also recommend looking at how some of the common editors like TinyMCE or KendoUI's Editor demos.kendoui.com/web/editor/custom-tools.html is implemented. â€“ Mark 8 mins ago